# -*- coding: utf-8 -*-
"""AI_presentation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1R1Z93qTq9UlaMSXae7_D2ZiZgsABGKE6
"""

# Non-deterministic Search | Simulated Annealing

import networkx as nx
import math
import random
import matplotlib.pyplot as plt

# Function to calculate Euclidean distance between two points
def euclidean_distance(coord1, coord2):
    return math.sqrt((coord1[0] - coord2[0])**2 + (coord1[1] - coord2[1])**2)
 Read the TSP file and extract node coordinates
tsp_file = "/content/drive/MyDrive/xqf131.tsp"  # Replace with the path to your TSP file

nodes = {}
with open(tsp_file, "r") as file:
    lines = file.readlines()
    # Find the line index where the node coordinates start
    coord_start_idx = lines.index("NODE_COORD_SECTION\n") + 1

    # Iterate over lines starting from the line containing node coordinates
    for line in lines[coord_start_idx:]:
        if line.startswith("EOF"):
            break
        parts = line.split()
        node_id = int(parts[0])  # Assuming the first column contains the node IDs
        x = float(parts[1])
        y = float(parts[2])
        nodes[node_id] = (x, y)

# Create a graph
G = nx.Graph()

# Add nodes with coordinates
for node_id, coords in nodes.items():
    G.add_node(node_id, pos=coords)

# Add edges with distances
for i in range(1, len(nodes) + 1):
    for j in range(i + 1, len(nodes) + 1):
        distance = euclidean_distance(nodes[i], nodes[j])
        G.add_edge(i, j, distance=distance)

# Simulated Annealing algorithm for TSP
def simulated_annealing(graph, max_iterations):
    def tour_length(tour):
        return sum(graph[tour[i]][tour[i + 1]]['distance'] for i in range(len(tour) - 1)) + graph[tour[-1]][tour[0]]['distance']

    current_tour = list(graph.nodes)
    random.shuffle(current_tour)
    current_length = tour_length(current_tour)

    best_tour = current_tour.copy()
    best_length = current_length

    for _ in range(max_iterations):
        neighbor_tour = current_tour.copy()
        i, j = sorted(random.sample(range(len(current_tour)), 2))
        neighbor_tour[i:j+1] = reversed(neighbor_tour[i:j+1])

        neighbor_length = tour_length(neighbor_tour)
        delta = neighbor_length - current_length

        if delta < 0 or random.random() < math.exp(-delta / current_length):
            current_tour = neighbor_tour
            current_length = neighbor_length

            if current_length < best_length:
                best_tour = current_tour.copy()
                best_length = current_length

    return best_tour, best_length

# Number of iterations for Simulated Annealing
max_iterations = 10000

# Run Simulated Annealing
best_tour, best_length = simulated_annealing(G, max_iterations)

print("Best tour:", best_tour)
print("Best length:", best_length)

# Visualize the best tour on the graph
pos = nx.get_node_attributes(G, 'pos')
nx.draw_networkx_nodes(G, pos, node_size=10)
nx.draw_networkx_edges(G, pos, width=0.5)
nx.draw_networkx_edges(G, pos, edgelist=[(best_tour[i], best_tour[i+1]) for i in range(len(best_tour)-1)], edge_color='r', width=2)
nx.draw_networkx_edges(G, pos, edgelist=[(best_tour[-1], best_tour[0])], edge_color='r', width=2)
plt.axis('off')
plt.show()

import networkx as nx

# Given path (list of nodes)
path =path_array = [1, 12, 5, 13, 18, 25, 16, 14, 15, 17, 19, 27, 26, 45, 53, 74, 64, 68, 75, 77, 78, 81, 82, 87, 88, 92, 94, 99, 93, 89, 98, 112, 123, 130, 121, 118, 114, 105, 100, 101, 102, 106, 107, 108, 113, 124, 125, 126, 131, 127, 128, 129, 122, 117, 120, 116, 119, 115, 109, 110, 111, 103, 104, 97, 96, 95, 91, 90, 86, 85, 84, 83, 79, 80, 72, 73, 61, 60, 59, 58, 63, 67, 71, 76, 70, 66, 69, 65, 62, 56, 57, 52, 51, 50, 49, 48, 47, 55, 54, 46, 28, 29, 20, 30, 31, 32, 21, 33, 34, 35, 36, 22, 37, 38, 39, 23, 40, 41, 42, 43, 44, 24, 11, 4, 10, 9, 3, 2, 8, 7, 6]  # Example path, replace with your actual path

# Function to calculate the length of a path in the graph G
def calculate_path_length(graph, path):
    total_length = 0
    for i in range(len(path) - 1):
        total_length += graph[path[i]][path[i+1]]['distance']
    total_length += graph[path[-1]][path[0]]['distance']  # Return to the starting point
    return total_length

# Example usage
# Assuming G is the graph containing distances between cities
length = calculate_path_length(G, path)
print("Length of the path:", length)

pos = nx.get_node_attributes(G, 'pos')
nx.draw_networkx_nodes(G, pos, node_size=10)
nx.draw_networkx_edges(G, pos, width=0.5)
nx.draw_networkx_edges(G, pos, edgelist=[(best_tour[i], best_tour[i+1]) for i in range(len(best_tour)-1)], edge_color='r', width=2)
nx.draw_networkx_edges(G, pos, edgelist=[(best_tour[-1], best_tour[0])], edge_color='r', width=2)
plt.axis('off')
plt.show()

# dp  held_karp time complexity  O(n^2 * 2^n)

import networkx as nx
import math

# Function to calculate Euclidean distance between two points
def euclidean_distance(coord1, coord2):
    return math.sqrt((coord1[0] - coord2[0])**2 + (coord1[1] - coord2[1])**2)

# Read the TSP file and extract node coordinates
tsp_file = "/content/drive/MyDrive/xqf131.tsp"  # Replace with the path to your TSP file

nodes = {}
with open(tsp_file, "r") as file:
    lines = file.readlines()
    # Find the line index where the node coordinates start
    coord_start_idx = lines.index("NODE_COORD_SECTION\n") + 1

    # Iterate over lines starting from the line containing node coordinates
    for line in lines[coord_start_idx:]:
        if line.startswith("EOF"):
            break
        parts = line.split()
        node_id = int(parts[0])  # Assuming the first column contains the node IDs
        x = float(parts[1])
        y = float(parts[2])
        nodes[node_id] = (x, y)

# Create a graph= nx.Graph()

# Add nodes with coordinates
for node_id, coords in nodes.items():
    G.add_node(node_id, pos=coords)

# Add edges with distances
for i in range(1, len(nodes) + 1):
    for j in range(i + 1, len(nodes) + 1):
        distance = euclidean_distance(nodes[i], nodes[j])
        G.add_edge(i, j, distance=distance)

# Function to compute the shortest tour length using Dynamic Programming (Held-Karp)
def held_karp(graph):
    # Number of nodes in the graph
    num_nodes = graph.number_of_nodes()

    # Initialize memoization table with infinite distances
    memo = [[float('inf')] * num_nodes for _ in range(2**num_nodes)]
    memo[1][0] = 0  # Base case: distance from start node to itself is 0

    # Iterate over all possible subsets of nodes
    for subset in range(1, 2**num_nodes):
        for end in range(1, num_nodes):
            if subset & (1 << end):  # Check if end node is in the current subset
                for start in range(num_nodes):
                    if start != end and subset & (1 << start):  # Check if start node is in the current subset
                        # Compute the shortest distance from start to end node in the current subset
                        memo[subset][end] = min(memo[subset][end], memo[subset ^ (1 << end)][start] + graph[start+1][end+1]['distance'])

    # Compute the final shortest tour length by adding the distance back to the start node
    min_length = min(memo[2**num_nodes - 1][end] + graph[end+1][0]['distance'] for end in range(1, num_nodes))

    return min_length

# Compute the shortest tour length using Dynamic Programming (Held-Karp)
shortest_length = held_karp(G)

print("Shortest tour length (Held-Karp):", shortest_length)

##Minimum Spanning Tree (MST) Heuristic: O(n^2 * log n)
# Add edges with distances
for i in range(1, len(nodes) + 1):
    for j in range(i + 1, len(nodes) + 1):
        distance = euclidean_distance(nodes[i], nodes[j])
        G.add_edge(i, j, distance=distance)

# Function to construct Minimum Spanning Tree (MST) using Prim's algorithm
def prim_mst(graph):
    mst_edges = nx.minimum_spanning_edges(graph, algorithm='prim', data=False)
    mst = nx.Graph(list(mst_edges))
    return mst

# Function to generate a tour from a Minimum Spanning Tree (MST)
def mst_tour(mst):
    tour = list(nx.dfs_preorder_nodes(mst, source=1))  # DFS traversal of the MST
    tour.append(tour[0])  # Add the starting node to complete the tour
    return tour

# Construct Minimum Spanning Tree (MST)
mst = prim_mst(G)

# Generate tour from MST
mst_tour = mst_tour(mst)

# Compute tour length
tour_length = sum(G[mst_tour[i]][mst_tour[i + 1]]['distance'] for i in range(len(mst_tour) - 1))

print("Tour:", mst_tour)
print("Tour length:", tour_length)

# Branch and Bound algorithm o(n!)

#Function to calculate the lower bound of a partial tour
def lower_bound(graph, tour):
    # Compute the total length of the current tour
    tour_length = sum(graph[tour[i]][tour[i + 1]]['distance'] for i in range(len(tour) - 1)) + graph[tour[-1]][tour[0]]['distance']

    # Compute the minimum outgoing edge for each node not in the tour
    min_outgoing = float('inf')
    for node in graph.nodes():
        if node not in tour:
            outgoing_edges = [(node, neighbor) for neighbor in graph.neighbors(node) if neighbor not in tour]
            if outgoing_edges:
                min_edge = min(outgoing_edges, key=lambda e: graph[e[0]][e[1]]['distance'])
                min_outgoing = min(min_outgoing, graph[min_edge[0]][min_edge[1]]['distance'])

    # Lower bound is the sum of tour length and minimum outgoing edges
    return tour_length + min_outgoing

# Function to perform depth-first search with branch and bound
def dfs_branch_and_bound(graph, current_tour, current_length, best_tour, best_length):
    if len(current_tour) == graph.number_of_nodes():
        # Complete tour found, update best tour if shorter
        if current_length < best_length:
            best_tour.clear()
            best_tour.extend(current_tour)
            best_length = current_length
    else:
        # Branch out to neighboring nodes not yet visited
        for neighbor in graph.neighbors(current_tour[-1]):
            if neighbor not in current_tour:
                # Check if lower bound is smaller than best length
                if current_length + graph[current_tour[-1]][neighbor]['distance'] < best_length:
                    # Explore the neighbor node
                    current_tour.append(neighbor)
                    current_length += graph[current_tour[-2]][current_tour[-1]]['distance']
                    best_tour, best_length = dfs_branch_and_bound(graph, current_tour, current_length, best_tour, best_length)
                    # Backtrack
                    current_tour.pop()
                    current_length -= graph[current_tour[-1]][neighbor]['distance']
    return best_tour, best_length

# Function to find the shortest tour using Branch and Bound method
def branch_and_bound_tsp(graph):
    # Start with node 1 as the initial tour
    initial_tour = [1]
    # Initialize best tour and length
    best_tour = []
    best_length = float('inf')
    # Perform depth-first search with branch and bound
    best_tour, best_length = dfs_branch_and_bound(graph, initial_tour, 0, best_tour, best_length)
    return best_tour, best_length

# Find the shortest tour using Branch and Bound method
shortest_tour, shortest_length = branch_and_bound_tsp(G)

print("Shortest tour:", shortest_tour)
print("Shortest tour length:", shortest_length)

import networkx as nx
import math
import random
import matplotlib.pyplot as plt

# Function to calculate Euclidean distance between two points
def euclidean_distance(coord1, coord2):
    return math.sqrt((coord1[0] - coord2[0])**2 + (coord1[1] - coord2[1])**2)

# Read the TSP file and extract node coordinates
tsp_file = "/content/drive/MyDrive/xqf131.tsp"

nodes = {}
with open(tsp_file, "r") as file:
    lines = file.readlines()
    # Find the line index where the node coordinates start
    coord_start_idx = lines.index("NODE_COORD_SECTION\n") + 1

    # Iterate over lines starting from the line containing node coordinates
    for line in lines[coord_start_idx:]:
        if line.startswith("EOF"):
            break
        parts = line.split()
        node_id = int(parts[0])  # Assuming the first column contains the node IDs
        x = float(parts[1])
        y = float(parts[2])
        nodes[node_id] = (x, y)

# Create a graph
G = nx.Graph()

# Add nodes with coordinates
for node_id, coords in nodes.items():
    G.add_node(node_id, pos=coords)

# Add edges with distances
for i in range(1, len(nodes) + 1):
    for j in range(i + 1, len(nodes) + 1):
        distance = euclidean_distance(nodes[i], nodes[j])
        G.add_edge(i, j, distance=distance)

# Function to calculate the total distance of a tour
def tour_distance(tour, graph):
    distance = 0
    for i in range(len(tour) - 1):
        distance += graph[tour[i]][tour[i + 1]]['distance']
    distance += graph[tour[-1]][tour[0]]['distance']  # Return to the starting point
    return distance

# Function to generate a random initial tour
def initial_tour(graph):
    tour = list(graph.nodes)
    random.shuffle(tour)
    return tour

# Function to generate a random neighbor by reversing a segment of the tour
def random_neighbor(tour):
    neighbor = tour.copy()
    i, j = sorted(random.sample(range(len(tour)), 2))
    neighbor[i:j+1] = reversed(neighbor[i:j+1])
    return neighbor

# Simulated Annealing algorithm for TSP
def simulated_annealing(graph, max_iterations):
    current_solution = initial_tour(graph)
    current_cost = tour_distance(current_solution, graph)

    best_solution = current_solution.copy()
    best_cost = current_cost

    for _ in range(max_iterations):
        neighbor_solution = random_neighbor(current_solution)

        delta = tour_distance(neighbor_solution, graph) - current_cost

        if delta < 0 or random.random() < math.exp(-delta / current_cost):
            current_solution = neighbor_solution
            current_cost = tour_distance(current_solution, graph)

            if current_cost < best_cost:
                best_solution = current_solution.copy()
                best_cost = current_cost

    return best_solution, best_cost

# Number of iterations for Simulated Annealing
max_iterations = 10000

# Run Simulated Annealing
best_tour, best_cost = simulated_annealing(G, max_iterations)

print("Best tour:", best_tour)
print("Best cost:", best_cost)

# Visualize the best tour on the graph
pos = nx.get_node_attributes(G, 'pos')
nx.draw_networkx_nodes(G, pos, node_size=10)
nx.draw_networkx_edges(G, pos, width=0.5)
nx.draw_networkx_edges(G, pos, edgelist=[(best_tour[i], best_tour[i+1]) for i in range(len(best_tour)-1)], edge_color='r', width=2)
nx.draw_networkx_edges(G, pos, edgelist=[(best_tour[-1], best_tour[0])], edge_color='r', width=2)
plt.axis('off')
plt.show()

import numpy as np
import pandas as pd
import random
import math
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots

class SA:
    def __init__(self, iterations, temp, df, gamma):
        self.iterations = iterations
        self.temp = temp
        self.df = df
        self.gamma = gamma

    def run(self):
        scores = []
        best_scores = []
        temps = []
        best_df = self.df.copy()
        best_score = self.calculate_score(best_df)

        for i in range(self.iterations):
            new_df = self.get_new_state(self.df)
            new_score = self.calculate_score(new_df)
            if new_score < best_score or random.random() < math.exp((best_score - new_score) / self.temp):
                self.df = new_df
                best_score = new_score
            scores.append(new_score)
            best_scores.append(best_score)
            temps.append(self.temp)
            self.temp *= self.gamma

        return scores, best_scores, temps, best_df

    def calculate_score(self, df):
        total_distance = sum(np.linalg.norm(df.iloc[i] - df.iloc[i + 1]) for i in range(len(df) - 1))
        return total_distance + np.linalg.norm(df.iloc[-1] - df.iloc[0])

    def get_new_state(self, df):
        new_df = df.copy()
        i, j = random.sample(range(len(df)), 2)
        new_df.iloc[i], new_df.iloc[j] = new_df.iloc[j], new_df.iloc[i]
        return new_df

# Sample DataFrame for demonstration
num_cities = 10
random.seed(42)  # For reproducibility
df = pd.DataFrame({
    'x': np.random.uniform(0, 100, num_cities),
    'y': np.random.uniform(0, 100, num_cities)
})

# Initialize parameters
iterations = 1000
temp = 1000
gamma = 0.99

# Create SA object
sa = SA(iterations, temp, df, gamma)

# Run simulated annealing
scores, best_scores, temps, best_df = sa.run()

# Plot the results
fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(go.Scatter(x=list(range(iterations)), y=scores, name='Current Score'))
fig.add_trace(go.Scatter(x=list(range(iterations)), y=best_scores, name='Best Score'))
fig.add_trace(go.Scatter(x=list(range(iterations)), y=temps, name='Temperature'), secondary_y=True)
fig.update_layout(template="simple_white", font=dict(size=15), title_text='Simulated Annealing',
                  width=800, title_x=0.5, height=450, xaxis_title='Iteration',
                  yaxis_title='Distance')
fig.update_yaxes(title_text="Temperature", secondary_y=True, automargin=True)
fig.update_xaxes(automargin=True)
fig.show()

# Plot resultant map
fig = px.line(best_df, x='x', y='y', text=best_df.index, title='Best City Map')
fig.update_layout(template="simple_white", width=750, title_x=0.5, font=dict(size=18))
fig.update_traces(textposition='top center')
fig.show()

import networkx as nx
import math
import random
import matplotlib.pyplot as plt

# Function to calculate Euclidean distance between two points
def euclidean_distance(coord1, coord2):
    return math.sqrt((coord1[0] - coord2[0])**2 + (coord1[1] - coord2[1])**2)

# Read the TSP file and extract node coordinates
tsp_file = "/content/drive/MyDrive/xqf131.tsp"  # Replace with the path to your TSP file

nodes = {}
with open(tsp_file, "r") as file:
    lines = file.readlines()
    # Find the line index where the node coordinates start
    coord_start_idx = lines.index("NODE_COORD_SECTION\n") + 1

    # Iterate over lines starting from the line containing node coordinates
    for line in lines[coord_start_idx:]:
        if line.startswith("EOF"):
            break
        parts = line.split()
        node_id = int(parts[0])  # Assuming the first column contains the node IDs
        x = float(parts[1])
        y = float(parts[2])
        nodes[node_id] = (x, y)

# Create a graph
G = nx.Graph()

# Add nodes with coordinates
for node_id, coords in nodes.items():
    G.add_node(node_id, pos=coords)

# Add edges with distances
for i in range(1, len(nodes) + 1):
    for j in range(i + 1, len(nodes) + 1):
        distance = euclidean_distance(nodes[i], nodes[j])
        G.add_edge(i, j, distance=distance)

# Function to calculate the total distance of a tour
def tour_distance(tour, graph):
    distance = 0
    for i in range(len(tour) - 1):
        distance += graph[tour[i]][tour[i + 1]]['distance']
    distance += graph[tour[-1]][tour[0]]['distance']  # Return to the starting point
    return distance

# Function to generate a random initial tour
def initial_tour(graph):
    tour = list(graph.nodes)
    random.shuffle(tour)
    return tour

# Function to generate a random neighbor by reversing a segment of the tour
def random_neighbor(tour):
    neighbor = tour.copy()
    i, j = sorted(random.sample(range(len(tour)), 2))
    neighbor[i:j+1] = reversed(neighbor[i:j+1])
    return neighbor
# Simulated Annealing algorithm for TSP with Metropolis rule
def simulated_annealing(graph, max_iterations, initial_temperature=100.0, cooling_rate=0.95):
    current_solution = initial_tour(graph)
    current_cost = tour_distance(current_solution, graph)

    best_solution = current_solution.copy()
    best_cost = current_cost

    temperature = initial_temperature

    for _ in range(max_iterations):
        neighbor_solution = random_neighbor(current_solution)

        delta = tour_distance(neighbor_solution, graph) - current_cost

        if delta < 0 or random.random() < math.exp(-delta / temperature):
            current_solution = neighbor_solution
            current_cost = tour_distance(current_solution, graph)

            if current_cost < best_cost:
                best_solution = current_solution.copy()
                best_cost = current_cost

        # Update temperature
        temperature *= cooling_rate

    return best_solution, best_cost


# Number of iterations for Simulated Annealing
max_iterations = 10000

# Run Simulated Annealing
best_tour, best_cost = simulated_annealing(G, max_iterations)

print("Best tour:", best_tour)
print("Best cost:", best_cost)

# Visualize the best tour on the graph
pos = nx.get_node_attributes(G, 'pos')
nx.draw_networkx_nodes(G, pos, node_size=10)
nx.draw_networkx_edges(G, pos, width=0.5)
nx.draw_networkx_edges(G, pos, edgelist=[(best_tour[i], best_tour[i+1]) for i in range(len(best_tour)-1)], edge_color='r', width=2)
nx.draw_networkx_edges(G, pos, edgelist=[(best_tour[-1], best_tour[0])], edge_color='r', width=2)
plt.axis('off')
plt.show()

import random
import numpy as np
import math

# Define the tourist locations in Rajasthan
tourist_locations = [
    "Jaipur", "Jodhpur", "Udaipur", "Jaisalmer", "Ranthambore National Park",
    "Ajmer Sharif Dargah", "Chittorgarh Fort", "Desert National Park",
    "Mount Abu", "Pushkar", "Thar Desert", "Bikaner", "Alwar", "Bharatpur",
    "Mandawa", "Shekhawati", "Kumbhalgarh Fort", "Nathdwara", "Sawai Madhopur",
    "Osian"
]

# Define the distances between tourist locations (example distances for illustration)
# Replace these distances with actual distances between locations in Rajasthan
distances = np.random.randint(50, 500, size=(len(tourist_locations), len(tourist_locations)))
np.fill_diagonal(distances, 0)  # Set diagonal elements to 0

def calculate_tour_distance(tour, distances):
    total_distance = 0
    for i in range(len(tour) - 1):
        total_distance += distances[tour[i]][tour[i + 1]]
    total_distance += distances[tour[-1]][tour[0]]  # Return to the starting location
    return total_distance

def simulated_annealing(distances, initial_temperature=1000, cooling_rate=0.001, num_iterations=1000):
    num_locations = len(distances)
    current_tour = random.sample(range(num_locations), num_locations)  # Initial random tour
    current_distance = calculate_tour_distance(current_tour, distances)
    best_tour = current_tour
    best_distance = current_distance
    temperature = initial_temperature

    for iteration in range(num_iterations):
        # Generate a new candidate tour by swapping two random locations
        new_tour = current_tour.copy()
        i, j = random.sample(range(num_locations), 2)
        new_tour[i], new_tour[j] = new_tour[j], new_tour[i]

        new_distance = calculate_tour_distance(new_tour, distances)

        # If the new tour is better or accepted probabilistically, update the current tour
        if new_distance < current_distance or random.random() < math.exp((current_distance - new_distance) / temperature):
            current_tour = new_tour
            current_distance = new_distance

        # Update the best tour found so far
        if current_distance < best_distance:
            best_tour =current_tour
            best_distance = current_distance

        # Cool the temperature
        temperature *= 1 - cooling_rate

    return best_tour, best_distance

# Perform simulated annealing to find the best tour
best_tour, best_distance = simulated_annealing(distances)

# Save the results to a TSP file
with open("tour_of_rajasthan.tsp", "w") as tsp_file:
    tsp_file.write("NAME: Tour of Rajasthan\n")
    tsp_file.write("TYPE: TSP\n")
    tsp_file.write("DIMENSION: {}\n".format(len(tourist_locations)))
    tsp_file.write("EDGE_WEIGHT_TYPE: EXPLICIT\n")
    tsp_file.write("EDGE_WEIGHT_FORMAT: FULL_MATRIX\n")
    tsp_file.write("EDGE_WEIGHT_SECTION\n")
    for i in range(len(tourist_locations)):
        tsp_file.write(" ".join(map(str, distances[i])) + "\n")
    tsp_file.write("TOUR_SECTION\n")
    tsp_file.write(" ".join(map(str, best_tour)) + "\n")
    tsp_file.write("-1\n")
    tsp_file.write("EOF\n")

print("Best tour:", best_tour)
print("Total distance:", best_distance)
print("Results saved to tour_of_rajasthan.tspfile.")